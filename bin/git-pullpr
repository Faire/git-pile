#!/usr/bin/env python3
import os
# given either the local_main_commit_hash or the pr_number
# find the remote branch
# pull it
# if the local branch exists and there are additional commits
#   ask if we should rebase or blow away local
#   - attempt to rebase off remote
#       if it fails - use mergetool
# squash branch into head commit
# if the local main commit exists
# - replace it with the squashed commit
# - otherwise add the commit to the top of the local main stack

# TODO: how do we handle $GIT_PILE_PREFIX?

from typing import List, Dict, Tuple
import argparse
import collections
import subprocess
import sys
import signal


class _GitError(Exception):
    pass


def signal_handler(sig, frame):
    worktree_dir = _run_git_command(["pileworktreepath"])
    _run_git_command(["-C", worktree_dir, "switch --detach --quiet"])
    sys.exit(0)


signal.signal(signal.SIGINT, signal_handler)


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser()
    # parser.add_argument(
    #     "--squash",
    #     action="store_true",
    #     help="Squash the commit instead of adding a new commit to the branch"
    # )
    return parser


def _run_git_command(args: List[str]) -> str:
    try:
        output: bytes = subprocess.check_output(["git"] + args)
        # TODO: got an exception here at some point
        return output.strip().decode("utf-8")
    except subprocess.CalledProcessError:
        raise _GitError()
    except UnicodeDecodeError:
        print(f"error: output was {output}")
        raise


def _is_in_repo() -> bool:
    try:
        _run_git_command(["rev-parse", "--show-toplevel"])
        return True
    except _GitError:
        return False


def _switch_to_branch_in_worktree(local_branch_name: str, worktree_dir: str) -> None:
    # check if directory exists
    if not os.path.exists(worktree_dir):
        _run_git_command(["worktree", "add", "--quiet", "--force", worktree_dir, local_branch_name])
    else:
        _run_git_command(["-C", worktree_dir, "switch", "--quiet", local_branch_name])


def _main(commit_args: List[str]) -> None:
    if not _is_in_repo():
        sys.exit("error: not in git repo")

    commit = _run_git_command(["rev-parse", commit_args[0] if commit_args else "HEAD"])
    local_pile_branch = _run_git_command(["symbolic-ref", "HEAD"])
    remote_pile_branch = _run_git_command(["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"])
    remote_pile_branch_remote = remote_pile_branch.split("/")[0]
    remote_pile_branch_name = "/".join(remote_pile_branch.split("/")[1:])
    pile_merge_base = _run_git_command(["merge-base", "@{upstream}", local_pile_branch])
    commits_on_the_pile = [s.strip('"') for s in
                           _run_git_command(["log", "--pretty=format:\"%H\"", f"{pile_merge_base}..HEAD"]).splitlines()]

    if commit not in commits_on_the_pile:
        sys.exit("error: commit is not on the pile")
        # TODO fetch PR using gh
        # get remote branch name
        # ("gh pr view 1 --json headRefName --jq .headRefName")

    local_branch_name = _run_git_command(["pilebranchname", commit])
    worktree_dir = _run_git_command(["pileworktreepath"])
    _switch_to_branch_in_worktree(local_branch_name, worktree_dir)
    remote_branch = _run_git_command(
        ["-C", worktree_dir, "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"])
    remote_branch_remote = remote_branch.split("/")[0]
    remote_branch_name = "/".join(remote_branch.split("/")[1:])
    # fetch branch
    _run_git_command(
        ["-C", worktree_dir, "fetch", "--quiet", remote_branch_remote, remote_branch_name, remote_pile_branch_name])
    # if local branch exists rebase onto remote TODO: optionally blow away local changes
    _run_git_command(["-C", worktree_dir, "rebase", "--quiet", remote_branch])

    # squash branch into pile
    # squash into a single commit
    # Perform the rebase with squashing without an interactive editor
    merge_base = _run_git_command(["merge-base", remote_branch, remote_pile_branch])
    os.environ["GIT_SEQUENCE_EDITOR"] = "sed -i -e '1,1!s/pick/fixup/'"
    os.environ["GIT_EDITOR"] = ":"
    _run_git_command(["-C", worktree_dir, "rebase", "--quiet", merge_base])

    # checkout commit
    # make temporary branch
    # cherry-pick merge_base..old_commit^
    # cherry-pick new_commit
    # cherry-pick old_commit..HEAD
    # _run_git_command(["-C", worktree_dir, "switch --detach --quiet $(git rev-parse --short HEAD)"])
    # _run_git_command(["-C", worktree_dir, "reset --soft", base_commit])
    # squash branch into head commit
    # _run_git_command(["add"] + changed_files)
    # code = subprocess.Popen(["git", "commit", "--quiet"] + args).wait()
    # if code != 0:
    #     raise SystemExit("error: failed to commit, not updating PR")

    # try:
    #     subprocess.check_call(update_command)
    # except subprocess.CalledProcessError:
    #     sys.exit(1)


if __name__ == "__main__":
    args, commit_args = _build_parser().parse_known_args()
    _main(commit_args)
